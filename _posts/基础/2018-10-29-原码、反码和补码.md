---
layout: post
category: 基础
uuid: 6a052db2-636b-542c-84a0-0d4d2424f93c
---
工科的出现是为了解决某些问题，那原码、反码和补码同样也是为了解决某些问题而产生的。那到底是要解决什么问题呢？  
全国人民都知道，pc电脑又叫计算机，计算机的最基本的功能就是计算，也就是数字的加减乘除。那好，我们来看看计算机到底是如何做加减乘除的。

在做计算前。需要先说明一下，计算机存储任何数据都是用二进制编码。文字是二进制、图像是二进制、视频是二进制同样数字也是二进制。这种二进制存储方式就是俗称的数字化。  
还有很重要的一点就是：计算机不会做减法。当我第一次听说的时候，很诧异，也很好奇。为什么呢？原来人们在设计计算机电路的时候，只保留了加法电路，从而简化了电路的设计与实现简单。只保留做加法的功能就能简化电路？  
我的回答是肯定的。在数学中：2-1 = 2+（-1）、2*3 = 2+2+2、4/3 = 4-3 = 4+(-3)。用加法就可以做数字的运算。  
数字是有正负的，那计算机是如何表达正负的呢？计算机先驱们规定：**最高位0表示正数，1表示负数**。

## 一、方式一
现在要计算机计算：3+2=？ 用4位二进制来表示。**直接写出十进制的二进制码**。  
计算规则为：二进制码相加，溢出就丢掉。

3+2 = 0011 + 0010 = 0101 = +5 结果正确

计算：3-2=？ 用4位二进制表示  
3-2 = 3+(-2) = 0011 + 1010 = 1101 = -5 错误  

计算：3-3=？ 用4位二进制表示  
3-3 = 3+(-3) = 0011 + 1011 = 1110 = -6 错误

计算：2-3=？ 用4位二进制表示  
2-3 = 2+(-3) = 0010 +  1011 =  1101 = -5 错误

计算：-3-2=？ 用4位二进制表示  
-3-2 = -3-2 = 1011 + 1010 = 1 0111 = 0111 = 7 错误   
> 10111等于0111是因为给的是4位，最高位溢出，所以得到了0111

小结：从上面5个计算结果来看，发现做减法一定是错误的（-3-2不是减法，而是需要强制写符号位的加法），做加法就没问题。
那我们得出的结论是：
1. 做减法错误
2. 0的表示有两种：0000 = +0，1000 = -0
3. 符号位需要强制写入

## 二、方式二
为了解决上面出现的几个问题，在上面的基础上做些调整：**正数不管，负数除开符号位，也就是最高位不管，其他的位置全部取反，是0变成1，1变成0**。  
计算规则为：在方式一的基础上，正数不用取反，负数取反，然后得到的二进制码相加，有溢出的话，就把剩下的部分加一，最后把加一所得的二进制码取反就是结果

还是分别计算上面的几个式子：  
3+2 = 0011 + 0010 = 0011 + 0010 = 0100 = 0101 正确  

3-2 = 3+(-2) = 0011 + 1010 = 0011 + 1101 = 1 0000 = 0001 = 0001 = 1 正确  
> 解释一下：1 0000 怎么就等于 0001了呢？其实是这样的，因为我们给的是4位，10000 长度为5位，所以最高位的1就溢出被丢弃掉了。因此，10000在4位的时候其实是为
> 0000，为了到达计算的准确性，只要有进位（溢出）我们就用结果加一。  

3-3 = 3+(-3) = 0011 + 1011 = 0011 + 1100 = 1111 = 1000 = -0 结果正确，符号错误

2-3 = 2+(-3) = 0010 + 1011 = 0010 + 1100 = 1110 = 1001 = -1 正确

-3-2 = 1011 + 1010 = 1100 + 1101 = 1 1001 = 1010 = 1101 = -5 正确  

小结：减法可以正确计算，但是溢出需要加一才能得正确的结果。同时又有+0和-0的结果出现，需要取绝对值才是正确的值。得出的结论是：
1. 减法正确
2. 0的表示有两种：0000 = 0000 = +0，1000 = 1111 = -0
3. 溢出需要加一才能得到准确结果
4. 在计算和取得最后结果之前，都需要做取反操作
5. 当结果为0的时候需要取绝对值

## 三、方式三
上面的方式二，虽然可以准确的做减法，但是同时也引入的一些新的问题，比如无法准确得到结果0、溢出需要加一操作等等。
在使用计算机的时候，经常会听到性能一词。上面的计算方式明显不合乎追求高性能的做法。那有没有什么方法可以解决这个问题呢，计算机发展了这么多年肯定是有的。
那我们就看看新的方法。

在方式二的取反基础上加一得到新的二进制编码，也就是：**正数不管，负数除开符号位，也就是最高位不管，其他的位置全部取反，是0变成1，1变成0，然后加1**。  
计算规则为：整数不管，负数取反然后做加法操作，溢出位不管，得到溢出之后的结果再做取反加一就是几个二进制码了

还是分别计算上面的几个式子：  
3+2 = 0011 + 0010 = 0011 + 0010 = 0011 + 0010 = 0101 = 0101 = 5 正确

3-2 = 3+(-2) = （0011 + 1010）二进制 = （0011 + 1101）取反 = （0011 + 1110）加一 = 1 0001 = （0001）溢出 = (0001)正数不管 = 1 正确

3-3 = 3+(-3) = 0011 + 1011 = 0011 + 1100 = 0011 + 1101 = 1 0000 = 0000 = 0 正确

2-3 = 2+(-3) = （0010 + 1011）二进制 = （0010 + 1100）取反 = （0010 + 1101）加一 = 1111 = （1000）取反 = （1001）加一 = -1 正确

-3-2 = -3+(-2) = （1011 + 1010）二进制 = （1100 + 1101）取反 = （1101 + 1110）加一 = 1 1011 = （1011）溢出 = （1100）取反 = （1101）加一 = -5 正确

小结：计算结果全部正确，没有特殊的需要判断的操作，因此解决了+0和-0的问题，也没有了溢出加一操作。所以计算都是相同操作。
因此得出的结论为：
1. 所有计算结果准确，且计算方式相同
2. 没有+0和-0的结果
3. 0000表示0，1000表示负的最小值，例如：8位就是：-128

“都到这里了，还是没有说原码、反码和补码的事“，肯定有朋友是这么想的。其实我已经说过了。方式一就是原码，方式二就是反码，方式三就是补码。那接下来我们来总结一下。

## 四、总结
原码、反码和补码都是为了计算而产生的。只不过补码是为了解决原码和反码所带来的问题。现在的计算机一般都是用反码来计算。因此如果要问某种数据类型取值范围的话，
应该先得到该类型所占的字节数，然后根据1byte = 8bit可以得出取值范围为：-2^(n\*8-1)~2^(n\*8-1)-1。比如：java的int占多少位。就是-2^(4\*8-1)~2^(4\*8-1)-1 = 
-2^31~2^31-1。

## 五、补码的推导
// TODO 

参考：
* [维基百科\-\-有符号数处理](https://zh.wikipedia.org/wiki/%E6%9C%89%E7%AC%A6%E8%99%9F%E6%95%B8%E8%99%95%E7%90%86)
* [张子秋\-\-原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)
