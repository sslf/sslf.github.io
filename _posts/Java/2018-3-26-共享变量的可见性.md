---
layout: post
category: Java
#permalink: /java/thread/var-visibility.html
---
### 一、什么是多线程共享变量的可见性
线程A对共享变量number的修改，在线程B中，能够及时的看到。

### 二、原子性
又叫代码执行不可分割性。顾名思义就是在程序执行的时候，获取了CPU执行权利后，该代码就必须要在这个运行状态中，全部执行完。不能执行一部分后等待下一次该线程的运行状态执行。

### 三、什么是共享变量
变量同时在多个线程中存在副本。那这个变量就是线程的共享变量。具体表现为：类的成员变量。

### 四、如何保证共享变量的可见性
换句话说就是：怎样才能保证变量在一个线程中的修改，其他线程可以准确无误的读取到。
要想实现这样的想法，那就要保证：变量在同一时刻，只能一个线程读取和修改。在Java中，提供了两个关键字来实现该操作。synchronized和volatile。

### 五、Java多线程简单的内存模型
内存分为：主内存和线程工作内存。如下图：
![Java内存模型（JMM）](http://ozsqtghjh.bkt.clouddn.com/11a575730e81de83b8bbf65f0597a000.png)

Java中所有的变量都存在于主内存中，线程工作内存中存放了共享变量的副本。

线程对共享变量的操作只能在自己的工作内存中进行，不能直接读取主内存。
不同线程之间不能访问其他线程的工作内存，线程间的变量传递只能通过主内存中转。

由上图可见：线程1对x的修改要想线程2及时看到要经过两个步骤：
1.把工程内存1中的共享变量刷新到主内存中。
2.线程2从主内存中同步共享变量到工作内存2中。

### 六、synchronized（同步）
作用：保证代码块的原子性和共享变量的可见性。
实现步骤：
1. 获取互斥锁。
2. 清空工作内存。
3. 把主内存中的共享变量存放到工作内存中。
4. 执行synchronized代码块。
5. 同步工作内存变量到主内存中。
6. 释放互斥锁。

### 七、volatile
作用：保证共享变量的可见性。
原理：在对volatile变量执行写操作后，立即强制线程把该共享变量的更新到主内存中。在执行读操作时，强制线程从主内存中读取该变量的值。
注意事项：一般在多线程中使用volatile变量，对变量的写操作不能依赖变量本身。如：number++，num = num * 5等。

### 八、synchronized和volatile对比
1. volatile只能保证共享变量的可见性。
2. synchronized既能保证可见性，也能保证原子性。
3. volatile不需要加锁。比synchronized更轻，还不会阻塞线程。
4. volatile只能修饰变量，synchronized能修饰类、方法和代码块。
5. synchronized能被编译器优惠，比如代码的重排序。
