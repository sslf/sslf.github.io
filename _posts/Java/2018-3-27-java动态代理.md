---
layout: post
category: Java
#permalink: /java/base/dynamicProxy.html
---
什么是[代理模式](/designPatterns/proxy.html)已经说明过了，那为什么Java又会有动态代理呢？

### 静态代理模式的缺点
1. 每代理一个类，都要编写一个代理类。如果需要代理大量的类那就不好维护代码了。
2. 如果代理要增加一个代理方法的话，那么所有的代理都需要同时修改。

### 什么是Java动态代理
代理实现的本质就是：生成一个代理类来代理执行。动态代理就是：动态生成一个代理类。也就是在
程序运行期间，由JVM通过反射机制动态的生成一个代理类。

### Java动态代理的分类
1. Jdk代理===接口代理
2. Cglib代理===子类代理

### jdk代理的实现方式

```java
/**
 * 定义一个卖火车票接口
 */
public interface IticketSales {
    void ticketSales();
}

/**
 * 火车站实现买票接口
 */
public Class TrainStation implement IticketSales {

    @Override
    public void ticketSales(){
        System.out.println("火车站卖票");
    }

}

import java.lang.reflect.InvocationHandler;  

public Class TrainStationProxy implement InvocationHandler {
    // 代理目标类
    Object target;

    public TrainStationProxy(){

    }

    public TrainStationProxy(Object target){
        this.target = target;
    }

    /**
     * @Parama proxy 动态生成的代理类
     * @Parama method 动态生成的代理类的被代理方法
     * @Parama args 被代理方法的参数列表
     */
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {  

        // 在目标对象的方法执行之前简单的打印一下
        System.out.println("------------------before------------------");

        // 执行目标对象的方法
        Object result = method.invoke(target, args);

        // 在目标对象的方法执行之后简单的打印一下
        System.out.println("-------------------after------------------");

        // 代理方法的返回值
        return result;
    }

    /**
     * 简化获取代理类的方式
     */
    public Object newProxyInstance(){
        Class targetClass = target.getClass();
        Proxy.newProxyInstance(targetClass.getClassLoader(), targetClass.getInterfaces(), this);
    }
}

/**
 * 测试
 */
public static void main(String[] args) {
    IticketSales iticketSales = new TrainStation();

    // 获取代理对象
    IticketSales trainStationProxy = (IticketSales) new TrainStationProxy(iticketSales).newProxyInstance();

    // 调用方法
    trainStationProxy.ticketSales();
}

```
### 问题：
1. 为什么jdk动态代理在没有实现接口类中不起作用？
2. 先生成的代理对象后，在调用的方法时，动态代理它怎么知道应该代理哪个方法，是不是把接口的所有方法都代理了？

在回答问题之前，我们先去看看Jdk是如何实现动态代理的。




### cglib代理的实现方式
